.. _rust-performance:

===========
Performance
===========

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Client Best Practices
---------------------

The ``Client`` handles many aspects of database connection behind the scenes that can require manual management for other database drivers;
it discovers server topology, monitors it for any changes, and maintains an internal connection pool.
This has implications for how a Client should be used for best performance.

Lifetime
--------

A ``Client`` should be as long-lived as possible.
Establishing a new ``Client`` is relatively slow and resource-intensive.
Ideally a ``Client`` should only be created once at application startup.
Because ``Client`` is implemented using an internal ``Arc``,
it can safely be shared across threads or tasks, and cloning it to pass to new contexts is extremely cheap.

.. code-block:: rust

   // This will be very slow because it's constructing and tearing down a `Client`
   // with every request.
   async fn handle_request_bad() -> Result<(), Box<dyn Error>> {
       let client = Client::with_uri_str("mongodb://example.com").await?;
       // Do something with the client
       Ok(())
   }

   // This will be much faster.
   async fn handle_request_good(client: &Client) -> Result<(), Box<dyn Error>> {
       // Do something with the client
       Ok(())
   }

This is evident when using a framework that provides connection pooling.
Because ``Client`` does its own pooling internally,
attempting to maintain a pool of ``Clients`` will result in worse performance than using a single one.

Runtime
-------

A ``Client`` is implicitly bound to the instance of the tokio or async-std runtime in which it was created.
Attempting to execute operations on a different runtime instance will cause incorrect behavior and unpredictable failures.
This is easy to accidentally invoke when testing, as the ``tokio::test`` or ``async_std::test`` helper macros create a new runtime for each test.

.. code-block:: rust

   use tokio::runtime::Runtime;
   use once_cell::sync::Lazy;

   static CLIENT: Lazy<Client> = Lazy::new(|| {
       let rt = Runtime::new().unwrap();
       rt.block_on(async {
           Client::with_uri_str("mongodb://example.com").await.unwrap()
       })
   });

   // This will inconsistently fail.
   #[tokio::test]
   async fn test_list_dbs() -> Result<(), Box<dyn Error>> {
       CLIENT.list_database_names(None, None).await?;
       Ok(())
   }

To work around this issue, either create a new ``Client`` for every async test,
or bundle the runtime along with the client and don't use the test helper macros.

.. code-block:: rust

   use tokio::runtime::Runtime;
   use once_cell::sync::Lazy;

   static CLIENT_RUNTIME: Lazy<(Client, Runtime)> = Lazy::new(|| {
       let rt = Runtime::new().unwrap();
       let client = rt.block_on(async {
           Client::with_uri_str("mongodb://example.com").await.unwrap()
       });
       (client, rt)
   });

   #[test]
   fn test_list_dbs() -> Result<(), Box<dyn Error>> {
       let (client, rt) = &*CLIENT_RUNTIME;
       rt.block_on(async {
           client.list_database_names(None, None).await
       })?;
       Ok(())
   }

or

.. code-block:: rust

   #[tokio::test]
   async fn test_list_dbs() -> Result<(), Box<dyn Error>> {
       let client = Client::with_uri_str("mongodb://example.com").await?;
       CLIENT.list_database_names(None, None).await?;
       Ok(())
   }

Parallelism
-----------

Where data operations are naturally parallelizable,
spawning many asynchronous tasks that use the driver concurrently is often the best way to achieve maximum performance,
as the driver is designed to work well in such situations.

.. code-block:: rust

   let client = Client::with_uri_str("mongodb://example.com").await?;

   for i in 0..5 {
       let client_ref = client.clone();

       task::spawn(async move {
           let collection = client_ref.database("items").collection::<Document>(&format!("coll{}", i));

           // Do something with the collection
       });
   }
