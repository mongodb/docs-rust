.. _rust-performance:

==========================
Performance Considerations
==========================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

In this guide, you can learn about best practices for optimizing performance of the {+driver-short+}.
The ``Client`` handles many aspects of database connection behind the scenes that can require manual management for other database drivers;
it discovers server topology, monitors it for any changes, and maintains an internal connection pool.
This has implications for how a ``Client`` should be used for best performance.

.. _rust-performance-client-lifecycle:

Best Practices
--------------

Client Lifecycle
~~~~~~~~~~~~~~~~

Creating a new ``Client`` instance is relatively slow and resource-intensive.
Therefore a ``Client`` instance should be as long-lived as possible.
The ``Client`` type does its own pooling internally.
Attempting to maintain a pool of ``Client`` instances will result in worse performance than using a single instance.

The ``Client`` type is implemented using an internal ``Arc``,
it can safely be shared across threads or tasks.
Cloning it to pass to new contexts is extremely cheap.
This means you can create a ``Client`` instance once at application startup and continually reuse it.

Consider the following code.
It constructs and tears down a ``Client`` instance with every request.

.. literalinclude:: /includes/fundamentals/code-snippets/performance.rs
   :language: rust
   :dedent:
   :start-after: start-perf-client-slow
   :end-before: end-perf-client-slow

Instead, pass a longer-lived ``Client`` instance to the handler function.
The following code accepts a pointer to an existing ``Client`` instance,
allowing many requests to share the same client:

.. literalinclude:: /includes/fundamentals/code-snippets/performance.rs
   :language: rust
   :dedent:
   :start-after: start-perf-client-faster
   :end-before: end-perf-client-faster

.. _rust-performance-runtime:

Runtime
~~~~~~~

A ``Client`` instance is bound to the instance of the ``tokio`` or ``async-std`` runtime in which it was created.
Attempting to execute operations on a different runtime instance can cause incorrect behavior and unpredictable failures.
This is easy to accidentally invoke when testing,
as the ``tokio::test`` or ``async_std::test`` helper macros create a new runtime for each test.

.. literalinclude:: /includes/fundamentals/code-snippets/performance-new-runtime.rs
   :language: rust
   :dedent:

To work around this issue, either create a new ``Client`` instance for every ``async`` test,
or bundle the runtime along with the ``Client`` instance and don't use the test helper macros.

.. literalinclude:: /includes/fundamentals/code-snippets/performance-bundle-runtime.rs
   :language: rust
   :dedent:

or

.. literalinclude:: /includes/fundamentals/code-snippets/performance-new-client.rs
   :language: rust
   :dedent:

.. _rust-performance-parallelism:

Parallelism
~~~~~~~~~~~

Where data operations are naturally parallelizable,
spawning many asynchronous tasks that use the driver concurrently is often the best way to achieve maximum performance,
as the driver is designed to work well in such situations.

.. literalinclude:: /includes/fundamentals/code-snippets/performance-parallel.rs
   :language: rust
   :dedent:

Additional Information
----------------------

For more information about the concepts in this guide, see the following documentation:

- `Client() <{+api+}/struct.Client.html>`__
- `sync <{+api+}/sync/index.html>`__
- `Arc <https://doc.rust-lang.org/std/sync/struct.Arc.html>`__

.. TODO link to Async page when done
