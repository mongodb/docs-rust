.. _rust-performance:

===========
Performance
===========

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

This guide contains best practices for optimizing performance of the MongoDB Rust client.
The ``Client`` handles many aspects of database connection behind the scenes that can require manual management for other database drivers;
it discovers server topology, monitors it for any changes, and maintains an internal connection pool.
This has implications for how a ``Client`` should be used for best performance.

Client Lifecycle
----------------

A ``Client`` should be as long-lived as possible.
Establishing a new ``Client`` is relatively slow and resource-intensive.
Ideally a ``Client`` should only be created once at application startup.
Because ``Client`` is implemented using an internal ``Arc``,
it can safely be shared across threads or tasks, and cloning it to pass to new contexts is extremely cheap.

This will be very slow because it's constructing and tearing down a `Client` with every request.

.. code-block:: rust

   async fn handle_request() -> Result<(), Box<dyn Error>> {
       let client = Client::with_uri_str("mongodb://example.com").await?;
       // Do something with the client
       Ok(())
   }

This will be much faster.

.. code-block:: rust
   async fn handle_request(client: &Client) -> Result<(), Box<dyn Error>> {
       // Do something with the client
       Ok(())
   }

This is evident when using a framework that provides connection pooling.
Because ``Client`` does its own pooling internally,
attempting to maintain a pool of ``Clients`` will result in worse performance than using a single one.

Runtime
-------

A ``Client`` is implicitly bound to the instance of the tokio or async-std runtime in which it was created.
Attempting to execute operations on a different runtime instance will cause incorrect behavior and unpredictable failures.
This is easy to accidentally invoke when testing, as the ``tokio::test`` or ``async_std::test`` helper macros create a new runtime for each test.

.. code-block:: rust

   use tokio::runtime::Runtime;
   use once_cell::sync::Lazy;

   static CLIENT: Lazy<Client> = Lazy::new(|| {
       let rt = Runtime::new().unwrap();
       rt.block_on(async {
           Client::with_uri_str("mongodb://example.com").await.unwrap()
       })
   });

   // This will inconsistently fail.
   #[tokio::test]
   async fn test_list_dbs() -> Result<(), Box<dyn Error>> {
       CLIENT.list_database_names(None, None).await?;
       Ok(())
   }

To work around this issue, either create a new ``Client`` for every async test,
or bundle the runtime along with the client and don't use the test helper macros.

.. code-block:: rust

   use tokio::runtime::Runtime;
   use once_cell::sync::Lazy;

   static CLIENT_RUNTIME: Lazy<(Client, Runtime)> = Lazy::new(|| {
       let rt = Runtime::new().unwrap();
       let client = rt.block_on(async {
           Client::with_uri_str("mongodb://example.com").await.unwrap()
       });
       (client, rt)
   });

   #[test]
   fn test_list_dbs() -> Result<(), Box<dyn Error>> {
       let (client, rt) = &*CLIENT_RUNTIME;
       rt.block_on(async {
           client.list_database_names(None, None).await
       })?;
       Ok(())
   }

or

.. code-block:: rust

   #[tokio::test]
   async fn test_list_dbs() -> Result<(), Box<dyn Error>> {
       let client = Client::with_uri_str("mongodb://example.com").await?;
       CLIENT.list_database_names(None, None).await?;
       Ok(())
   }

Parallelism
-----------

Where data operations are naturally parallelizable,
spawning many asynchronous tasks that use the driver concurrently is often the best way to achieve maximum performance,
as the driver is designed to work well in such situations.

.. code-block:: rust

   let client = Client::with_uri_str("mongodb://example.com").await?;

   for i in 0..5 {
       let client_ref = client.clone();

       task::spawn(async move {
           let collection = client_ref.database("items").collection::<Document>(&format!("coll{}", i));

           // Do something with the collection
       });
   }

..
   Additional Information
   ----------------------

   For more information about the concepts in this guide, see the following documentation:

   - :manual:`db.runCommand() </reference/method/db.runCommand/>`
   - :manual:`Database Commands </reference/command/>`
   - :manual:`hello Command </reference/command/hello/>`
   - :manual:`explain Command </reference/command/explain/>`

   API Documentation
   ~~~~~~~~~~~~~~~~~

   - `run_command() <{+api+}/struct.Database.html#method.run_command>`__
   - `SelectionCriteria <{+api+}/options/enum.SelectionCriteria.html>`__
   - `ReadPreference <{+api+}/options/enum.ReadPreference.html>`__
