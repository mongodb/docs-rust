.. _rust-performance:

==========================
Performance Considerations
==========================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

In this guide, you can learn how to optimize performance of the {+driver-short+}.
In the {+driver-short+}, you must create a ``Client`` instance to connect to MongoDB. Your ``Client``
instance automatically handles most aspects of connection, such as discovering server topology, monitoring
your connection, and maintaining an internal connection pool. This guide describes best practices to configure and use your ``Client`` instance.

.. _rust-performance-client-lifecycle:

Client Lifecycle
----------------

Creating a new ``Client`` instance is relatively slow and resource-intensive.
Therefore a ``Client`` instance should be as long-lived as possible.
The ``Client`` automatically manages connection pooling.
When you create a single ``Client`` instance for multiple operations, you optimize its performance.

Cloning it to pass to new contexts is extremely cheap.
This means you can create a ``Client`` instance once at application startup and continually reuse it.

Consider the following code.
It constructs and tears down a ``Client`` instance with every request.

.. literalinclude:: /includes/fundamentals/code-snippets/performance.rs
   :language: rust
   :dedent:
   :start-after: start-perf-client-slow
   :end-before: end-perf-client-slow

Instead, pass a longer-lived ``Client`` instance to the handler function.
The following code accepts a pointer to an existing ``Client`` instance,
allowing many requests to share the same client:

.. literalinclude:: /includes/fundamentals/code-snippets/performance.rs
   :language: rust
   :dedent:
   :start-after: start-perf-client-faster
   :end-before: end-perf-client-faster

.. _rust-performance-runtime:

Runtime
-------

A ``Client`` instance is bound to the instance of the ``tokio`` or ``async-std`` runtime in which you created it.
If you use a ``Client`` instance to execute operations on a different runtime, you might experience unexpected behavior or failures.

If you are using the ``test`` helper macro from the ``tokio`` or ``async_std`` crate to test your application,
you might accidentally run operations on a different runtime than you intended.
This is because these helper macros create a new runtime for each test.

.. literalinclude:: /includes/fundamentals/code-snippets/performance-new-runtime.rs
   :language: rust
   :dedent:

To work around this issue, either create a new ``Client`` instance for every ``async`` test,
or bundle the runtime along with the ``Client`` instance and don't use the test helper macros.

.. literalinclude:: /includes/fundamentals/code-snippets/performance-bundle-runtime.rs
   :language: rust
   :dedent:

or

.. literalinclude:: /includes/fundamentals/code-snippets/performance-new-client.rs
   :language: rust
   :dedent:

.. _rust-performance-parallelism:

Parallelism
-----------

If you can run parallel data operations, creating asynchronous, concurrent tasks achieves maximum performance.

.. literalinclude:: /includes/fundamentals/code-snippets/performance-parallel.rs
   :language: rust
   :dedent:

API Documentation
-----------------

- `Client() <{+api+}/struct.Client.html>`__
- `sync <{+api+}/sync/index.html>`__

.. TODO link to Async page when done
