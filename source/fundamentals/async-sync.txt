.. _rust-async-sync:

=====================================
Asynchronous and Synchronous Runtimes
=====================================

.. contents:: On this page
   :local:
   :backlinks: nones
   :depth: 2
   :class: singlecol

Overview
--------

In this guide, you can learn how to use the driver's asynchronous and synchronous APIs.

{+driver-short+} supports both ``tokio`` and ``async-std``, the two most popular asynchronous runtime crates.
By default, the driver uses ``tokio``, but you can explicitly choose a runtime
by specifying one of ``tokio-runtime`` or ``async-std-runtime`` feature flags in your ``Cargo.toml``.

The driver also includes a synchronous API for simplicity, or when parallelism is not necessary.

Configure the asynchronous runtime
--------------------------------------

The driver uses ``tokio`` by default.
To use ``async-std``, add the following to your ``Cargo.toml``:

.. code-block:: toml

   [dependencies.mongodb]
   version = "2.6.0"
   default-features = false
   features = ["async-std-runtime"]

Enable the sync API
---------------------

The driver also provides a blocking sync API.
To enable this, add the ``sync`` or ``tokio-sync`` feature to your ``Cargo.toml``.

.. code-block:: toml

   [dependencies.mongodb]
   version = "2.6.0"
   default-features = false
   features = ["sync"]

The sync-specific types can be imported from ``mongodb::sync`` (e.g. ``mongodb::sync::Client``).

..
   Warning about timeouts / cancellation
   -------------------------------------

   In async Rust, it is common to implement cancellation and timeouts
   by dropping a future after a certain period of time instead of polling it to completion.
   However, doing this with futures returned by the driver can leave the driver's internals in an inconsistent state,
   which may lead to unpredictable or incorrect behavior.
   As such, it is highly recommended to poll all futures returned from the driver to completion.

   To use timeout mechanisms like ``tokio::time::timeout`` with the driver,
   one option is to spawn tasks and time out on their JoinHandle futures instead of on the driver’s futures directly.
   This will ensure the driver’s futures will always be completely polled while also allowing the application to continue in the event of a timeout.

   e.g.


   .. code-block:: rust

      let collection = client.database("foo").collection("bar");
      let handle = tokio::task::spawn(async move {
          collection.insert_one(doc! { "x": 1 }, None).await
      });

      tokio::time::timeout(Duration::from_secs(5), handle).await???;

Additional information
----------------------

For more information about the concepts in this guide, see the following pages:

- :ref:`Performance Considerations <rust-performance>`

API Documentation
-----------------

To learn more about the methods and types discussed in this
guide, see the following API Documentation:

- `mongodb::sync <{+api+}/sync/index.html>`__
